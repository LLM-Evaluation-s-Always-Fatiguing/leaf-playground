请你根据我提供给你的 `scene_definition.py` 代码，实现指定角色的模块。

你需要：
1 导入所需模块：
    1.1 从 scene_definition.py 中导入所有列在 __all__ 中的对象、变量和常量（其中包含各种类型定义、变量和 SCENE_DEFINITION 常量）
    1.2 根据角色是否是静态的，从 leaf_playground.core.scene_agent 导入相应的抽象基类
    1.3 根据实际情况导入其他所需要的第三方库、模块、对象或函数
2 使用 `SCENE_DEFINITION.get_role_definition({{ role_name }})` 获取相应角色的定义并赋给 `ROLE_DEFINITION`
3 创建名为 {{ role_name.title }}Config 的智能体配置数据模型：
   - 如果是静态角色，则使用 SceneStaticAgentConfig.create_config_model(ROLE_DEFINITION) 直接创建类对象
   - 否则，继承自 SceneAIAgentConfig 并将具体实现留空
   注意，以上使用的两个基类都是 `pydantic.BaseModel` 的子类
4 创建名为 {{ role_name.title }} 的智能体类，根据是否是静态角色继承自 1.2 对应导入的抽象类，并额外传入两个元类属性：
  - role_definition：值为 3 中的 `ROLE_DEFINITION`
  - cls_description：值取自 `ROLE_DEFINITION.description`
  如果角色不是静态角色，还需要额外继承 `abc.ABC` 以声明其为一个抽象类
5 根据 `ROLE_DEFINITION.actions` 实现预定义的每一个方法，注意方法的签名必须与 signature 定义的完全一致，且所有方法都必须是异步的
    5.1 判断 `is_static_method` 的值，若为 True，则该方法应该是一个静态方法，即加上 @statistic_method 装饰器
    5.2 判断角色是否是静态角色，即 `role.is_static` 是否为 True，若是，则你需要结合 scene_definition.py 中的信息和你对场景业务的理解来具体实现所有方法的逻辑；否则，你需要将所有方法定义为抽象方法（即使用 @abstractmethod 装饰器），不实现各方法的具体逻辑。
6 在 __all__ 中包含 `ROLE_DEFINITION`, `{{ role_name.title }}Config` 和 `{{ role_name.title }}`

注意，scene_definition.py 文件存储在你要实现的模块所在目录的上层目录中，因此你需要使用 `from ..scene_definition import *` 来导入其中的内容

为了你能更好地使用上述的相关模块，如 leaf_playground.core.scene_agent 模块，下面给出部分相关源码：

```python
# leaf_playground.core.scene_agent 模块

# 这里省略导入语句

class _ActionHandler:
    def __init__(self, action_fn: callable, action_name: str, exec_timeout: int, executable: asyncio.Event):
        self.action_fn = action_fn
        self.action_name = action_name
        self.exec_timeout = exec_timeout

        self.executable = executable
        # this will force the same action of one instance be called once in every moment
        # thus calling the same action of one instance multiple times concurrently
        # it will still run sequentially
        self._lock = asyncio.Lock()
        self._task = None
        self._clock = None
        self._executed_seconds = 0.0

    async def _record_executed_seconds(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def _reset_clock(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def _reset(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    async def execute(self, *args, **kwargs):
        ...  # 这里省略具体代码实现，可忽略此方法

    @property
    def task(self):
        return self._task


class _HumanActionHandler(_ActionHandler):
    def __init__(
        self,
        human_agent: "SceneHumanAgent",
        action_fn: callable,
        action_name: str,
        exec_timeout: int,
        executable: asyncio.Event,
    ):
        super().__init__(action_fn, action_name, exec_timeout, executable)
        self.human_agent = human_agent

    async def execute(self, *args, **kwargs):
        ...  # 这里省略具体代码实现，可忽略此方法


class SceneAgentMetadata(BaseModel):
    ...  # 这里省略具体代码实现，可忽略


class SceneAgentMetaClass(ABCMeta):
    def __new__(
        cls,
        name,
        bases,
        attrs,
        *,
        role_definition: RoleDefinition = None,
        cls_description: str = None,
        action_exec_timeout: int = None,
    ):
        attrs["role_definition"] = Immutable(role_definition or getattr(bases[0], "role_definition", None))
        attrs["cls_description"] = Immutable(cls_description)
        if action_exec_timeout is None:
            action_exec_timeout = getattr(bases[0], "action_exec_timeout", 30)
        attrs["action_exec_timeout"] = Immutable(action_exec_timeout)
        attrs["obj_for_import"] = Immutable(DynamicObject(obj=name, module=_getframe(1).f_globals["__name__"]))

        new_cls = super().__new__(cls, name, bases, attrs)

        # 这里省略部分具体实现代码

        return new_cls

    def __init__(
        cls,
        name,
        bases,
        attrs,
        *,
        role_definition: RoleDefinition = None,
        cls_description: str = None,
        action_exec_timeout: int = 30,
    ):
        super().__init__(name, bases, attrs)


class SceneAgentConfig(_Config):
    profile: Profile = Field(default=...)
    chart_major_color: Optional[str] = Field(default=None, pattern=r"^#[0-9a-fA-F]{6}$")


class SceneAgent(_Configurable, ABC, metaclass=SceneAgentMetaClass):
    config_cls = SceneAgentConfig
    config: config_cls

    # class attributes initialized in metaclass
    role_definition: RoleDefinition
    cls_description: str
    action_exec_timeout: int
    obj_for_import: DynamicObject

    def __init__(self, config: config_cls):
        super().__init__(config=config)

        self._profile = self.config.profile
        self._role = self.role_definition.role_instance
        self._profile.role = self._role
        self._env_vars: Dict[str, EnvironmentVariable] = None

        self._not_paused = asyncio.Event()
        self._not_paused.set()
        self._action2handler = {}
        if ABC not in self.__class__.__bases__:
            for action in self.role_definition.actions:
                action_name = action.name
                action_handler = _ActionHandler(
                    getattr(self, action_name), action_name, self.action_exec_timeout, self._not_paused
                )
                setattr(self, action_name, action_handler.execute)
                self._action2handler[action_name] = action_handler

    def bind_env_vars(self, env_vars: Dict[str, EnvironmentVariable]):
        self._env_vars = env_vars

    def pause(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def resume(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    @property
    def env_vars(self) -> Dict[str, EnvironmentVariable]:
        return self._env_vars

    @property
    def profile(self):
        return self._profile

    @property
    def role(self):
        return self._role

    @property
    def id(self):
        return self.profile.id

    @property
    def name(self):
        return self.profile.name

    @property
    def role_name(self):
        return self.role.name

    @property
    def env_var(self):
        return self._env_vars

    @classmethod
    def from_config(cls, config: config_cls) -> "SceneAgent":
        ...  # 这里省略具体代码实现，可忽略此方法

    @classmethod
    def get_metadata(cls):
        ...  # 这里省略具体代码实现，可忽略此方法


class SceneDynamicAgentConfig(SceneAgentConfig):
    def model_post_init(self, __context) -> None:
        pass


class SceneDynamicAgent(SceneAgent, ABC):
    config_cls = SceneDynamicAgentConfig
    config: config_cls

    def __init__(self, config: config_cls):
        super().__init__(config=config)

        self.connected = False

    @abstractmethod
    def connect(self, *args, **kwargs):
        pass

    @abstractmethod
    def disconnect(self, *args, **kwargs):
        pass


class SceneAIAgentConfig(SceneDynamicAgentConfig):
    ai_backend_config: AIBackendConfig = Field(default=...)
    ai_backend_obj: DynamicObject = Field(default=..., exclude=True)

    def model_post_init(self, __context) -> None:
        ...  # 这里省略具体代码实现，可忽略此方法

    def create_backend_instance(self) -> AIBackend:
        ...  # 这里省略具体代码实现，可忽略此方法

    @staticmethod
    def valid(ai_backend_config: AIBackendConfig, ai_backend_obj: DynamicObject):
        ...  # 这里省略具体代码实现，可忽略此方法


class SceneAIAgent(SceneDynamicAgent, ABC):
    config_cls = SceneAIAgentConfig
    config: config_cls

    def __init__(self, config: config_cls):
        super().__init__(config=config)

        self.backend = self.config.create_backend_instance()
        self.connected = True

    def connect(self):
        pass

    def disconnect(self):
        pass


class HumanConnection:
    def __init__(self, agent: "SceneHumanAgent", socket: WebSocket):
        self.agent = agent
        self.socket = socket

        self.events = asyncio.Queue()
        self.state = WebSocketState.CONNECTING

        self.cancel_event = asyncio.Event()

    async def connect(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def disconnect(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def notify_human_to_input(self):
        self.events.put_nowait(SocketEvent(event="wait_human_input"))

    def notify_human_to_not_input(self):
        self.events.put_nowait(SocketEvent(event="disable_human_input"))

    def notify_to_cancel(self):
        self.cancel_event.set()

    async def _keep_alive(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    async def _send_socket_event(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    async def _receive_human_input(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    async def run(self):
        ...  # 这里省略具体代码实现，可忽略此方法


class SceneHumanAgentConfig(SceneDynamicAgentConfig):
    pass


class SceneHumanAgent(SceneDynamicAgent, ABC):
    config_cls = SceneHumanAgentConfig
    config: config_cls

    def __init__(self, config: config_cls):
        super().__init__(config=config)

        self.connection: HumanConnection = None
        self.human_input = None
        self.wait_human_input = False

        if ABC not in self.__class__.__bases__:
            for action in self.role_definition.actions:
                action_name = action.name
                action_handler = _HumanActionHandler(
                    self,
                    self._action2handler[action_name].action_fn,
                    action_name,
                    self.action_exec_timeout,
                    self._not_paused,
                )
                setattr(self, action_name, action_handler.execute)
                self._action2handler[action_name] = action_handler

    def connect(self, connection: HumanConnection):
        self.connection = connection
        self.connected = True

    def disconnect(self):
        self.connection = None
        self.connected = False

    async def wait_human_text_input(self) -> Optional[str]:
        if not self.connected:
            return None
        self.wait_human_input = True
        self.connection.notify_human_to_input()
        while not self.human_input:
            await asyncio.sleep(0.1)
        self.wait_human_input = False
        if self.connected:
            self.connection.notify_human_to_not_input()
        human_input = self.human_input
        self.human_input = None
        return human_input

    async def wait_human_image_input(self, *args, **kwargs):
        raise NotImplementedError()  # TODO: impl

    @classmethod
    def get_metadata(cls):
        metadata = super().get_metadata()
        metadata.is_human = True
        return metadata


class SceneStaticAgentConfig(SceneAgentConfig):
    def model_post_init(self, __context: Any) -> None:
        ...  # 这里省略具体代码实现，可忽略此方法

    @classmethod
    def create_config_model(cls, role_definition: RoleDefinition) -> "SceneStaticAgentConfig":
        ...  # 这里省略具体代码实现，可忽略此方法


class SceneStaticAgent(SceneAgent, ABC):
    config_cls = SceneStaticAgentConfig
    config: config_cls

    def __init__(self, config: config_cls):
        super().__init__(config=config)
```

以下是角色的实现示例，假设在 scene_definition.py 中定义了这是一个老师（静态角色）基于一份多项选择题试卷对学生（非静态角色）进行测试的场景，老师具有准备问题（async def prepare_questions(self, ds_config: DatasetConfig) -> None），发题（async def send_question(self, receivers: List[Profile]) -> Question）和检查考试（async def check_examine_finished(self) -> bool）是否结束的动作，学生具有答题（async def answer_question(self, question: Question, receivers: List[Profile]) -> Answer）的动作。除了 SCENE_DEFINITION，scene_definition.py 中还定义了 Question 和 Answer 两个继承自 leaf_playground.data.message.Message 的数据结构，则 teacher.py 和 student.py 模块分别实现如下：

> 注意：因为老师是静态角色，因此 teacher.py 模块中 Teacher 类的所有动作方法需要被具体实现
<code file="teacher.py">
import json
import random
from typing import List

from leaf_playground.core.scene_agent import SceneStaticAgentConfig, SceneStaticAgent
from leaf_playground.data.media import Json

from ..scene_definition import *
from ..dataset_utils import DatasetConfig


ROLE_DEFINITION = SCENE_DEFINITION.get_role_definition("teacher")


class TeacherConfig(SceneStaticAgentConfig):
    pass


class Teacher(
    SceneStaticAgent,
    role_definition=ROLE_DEFINITION,
    cls_description=ROLE_DEFINITION.description  # you can change to your customized description
):
    config_cls = TeacherConfig
    config: config_cls

    def __init__(config: config_cls):
        super().__init__(config=config)

        self.questions: List[dict] = []
        self._question_id = 0

    async def prepare_questions(self, ds_config: DatasetConfig) -> None:
        with open(ds_config.file_path, "r", encoding="utf-8") as f:
            raw_questions = [each for each in f.read_lines()]
        raw_questions = random.sample(raw_questions, min(len(raw_questions), ds_config.num_questions))
        self.questions = [json.loads(each) for each in raw_questions]

    async def send_question(self, receivers: List[Profile]) -> Question:
        question = Question(
            sender=self.profile,
            receivers=receivers,
            content=Json(data=self.questions.pop(0)),
            question_id=self._question_id
        )
        self._question_id += 1
        return question

    async def check_examine_finished(self) -> bool:
        return bool(self.questions)


__all__ = ["ROLE_DEFINITION", "TeacherConfig", "Teacher"]
</code>

> 注意：因为学生是动态角色，因此 student.py 模块中 Student 类的所有动作方法都需要定义为抽象方法，而类本身也需要定义为抽象类

<code file="student.py">
from abc import abstractmethod, ABC

from leaf_playground.core.scene_agent import SceneAIAgentConfig, SceneAIAgent
from leaf_playground.data.media import Json

from ..scene_definition import *


ROLE_DEFINITION = SCENE_DEFINITION.get_role_definition("student")


class StudentConfig(SceneAIAgentConfig):
    pass


class Student(
    SceneAIAgent,
    role_definition=ROLE_DEFINITION,
    cls_description=ROLE_DEFINITION.description  # you can change to your customized description
):
    config_cls = TeacherConfig
    config: config_cls

    @abstractmethod
    async def answer_question(self, question: Question, receivers: List[Profile]) -> Answer:
        pass


__all__ = [ROLE_DEFINITION, "StudentConfig", "Student"]
</code>

请遵循上面的需求，并参照我提供给你的实例代码结构，根据我之后指定的角色，实现对应的 {{ role_name }}.py 模块。请直接给我代码，不要说其他的话。每个模块的代码使用<code file="{{ role_name }}.py">...</code>包裹，其中 {{ role_name }} 为角色名。回复“明白”以继续。
请你根据我提供给你的 `scene_definition.py` 代码，实现指定场景模块（scene.py）。

你需要：
1 导入所需模块：
    1.1 从 scene_definition.py 中导入所有列在 __all__ 中的对象、变量和常量（其中包含各种类型定义、变量和 SCENE_DEFINITION 常量）
    1.2 从 leaf_playground.core.scene 中导入 Scene 对象
    1.3 从 leaf_playground.core.scene_definition 中导入 SceneConfig 数据模型
    1.4 从 leaf_playground.data.log_body 中导入 ActionLogBody 数据模型
    1.5 从 agents 包下各角色模块中导入各角色对应的智能体基类，这主要是为了方便在代码中加入 annotations
    1.6 根据实际情况导入其他所需要的第三方库、模块、对象或函数
2 使用 SceneConfig 类（继承自 pydantic.BaseModel）的 create_config_model 方法创建一个名为 {{ scene_name.camel }}SceneConfig 数据模型，该方法接收 `scene_definition: SceneDefinition` 和 `additional_config_fields: Optional[dict[str, pydantic.Field]] = None` 参数，第一个参数传入在 1.1 步中导入的 SCENE_DEFINITION 常量，第二个参数根据实际情况赋值
3 实现名为 {{ scene_name.camel }}LogBody 的数据模型，继承自 1.4 步中导入的 ActionLogBody（这是一个 pydantic.BaseModel 的子类），你可以根据具体情况添加新的字段来记录更丰富的信息
4 实现名为 {{ scene_name.camel }}Scene 的场景类对象，继承自从 1.2 步中导入的 Scene 类对象，并设置以下元类参数：
    - scene_definition：值为 1.1 步中导入的 SCENE_DEFINITION 常量
    - log_body_class: 值为 3 步中定义的 {{ scene_name.camel }}LogBody 数据模型
  并继承父类的抽象方法 `async def _run(self) -> None:`，根据 scene_definition.py 中可知的消息（以及，如果有的话，我在之后提供给你的具体需求描述）实现场景流程，主要是各类角色对应的智能体实例直接的交互逻辑，并对各智能体动作执行的返回结果，使用 `self.log_body_class` 创建具体的 {{ scene_name.camel }}LogBody 实例，使用 `self.logger.add_log` 方法作记录，以及使用 `self.notify_evaluators_record` 方法提交日志给评估器进行评估
5 在 __all__ 中包含 `{{ role_name.camel }}SceneConfig` 和 `{{ role_name.camel }}Scene`

注意，scene_definition.py 文件存储在你要实现的模块在同一目录，因此你需要使用 `from .scene_definition import *` 来导入其中的内容

为了你能更好地使用上述的相关模块，如 Scene、ActionLogBody，下面给出部分相关源码：

```python
# Scene 的部分源码，来自 leaf_playground.core.scene 模块

# 这里省略导入语句

class SceneMetaClass(ABCMeta):
    def __new__(
        cls,
        name,
        bases,
        attrs,
        *,
        scene_definition: SceneDefinition = None,
        log_body_class: Type[ActionLogBody] = ActionLogBody,
    ):
        attrs["scene_definition"] = Immutable(scene_definition or getattr(bases[0], "scene_definition", None))
        attrs["log_body_class"] = Immutable(log_body_class)
        attrs["obj_for_import"] = Immutable(DynamicObject(obj=name, module=_getframe(1).f_globals["__name__"]))

        new_cls = super().__new__(cls, name, bases, attrs)

        # 这里省略部分具体实现代码

        return new_cls

    def __init__(
        cls,
        name,
        bases,
        attrs,
        *,
        scene_definition: SceneDefinition = None,
        log_body_class: Type[ActionLogBody] = ActionLogBody,
    ):
        super().__init__(name, bases, attrs)


class SceneMetadata(BaseModel):
    ...  # 这里省略具体代码实现，可忽略


class Scene(_Configurable, ABC, metaclass=SceneMetaClass):
    config_cls = SceneConfig
    config: SceneConfig

    # class attributes initialized in metaclass
    scene_definition: SceneDefinition
    log_body_class: Type[ActionLogBody]
    obj_for_import: DynamicObject

    def __init__(self, config: config_cls):
        super().__init__(config=config)

        static_roles = [role_def.name for role_def in self.scene_definition.roles if role_def.is_static]
        dynamic_roles = [role_def.name for role_def in self.scene_definition.roles if not role_def.is_static]
        agents: Dict[str, List[SceneAgent]] = self.config.init_agents()
        self.static_agents = {role_name: agents[role_name] for role_name in static_roles}
        self.agents = {role_name: agents[role_name] for role_name in dynamic_roles}
        self.env_vars: Dict[str, EnvironmentVariable] = self.config.init_env_vars()
        self._bind_env_vars_to_agents()
        self.evaluators: List[MetricEvaluator] = []

        self.logger = Logger.get_instance()
        self.message_pool = MessagePool.get_instance()

        self._dynamic_agents: Dict[str, SceneDynamicAgent] = {}
        self._agent_list: List[SceneAgent] = []
        self._human_agents: List[SceneHumanAgent] = []
        for agents_ in self.agents.values():
            self._human_agents += [agent for agent in agents_ if isinstance(agent, SceneHumanAgent)]
            self._agent_list += agents_
            self._dynamic_agents.update(**{agent.id: agent for agent in agents_})
        for agents_ in self.static_agents.values():
            self._agent_list += agents_

        self._run_task: Optional[asyncio.Task] = None

    @property
    def dynamic_agents(self) -> Dict[str, SceneDynamicAgent]:
        return self._dynamic_agents

    @property
    def human_agents(self) -> List[SceneHumanAgent]:
        return self._human_agents

    def get_dynamic_agent(self, agent_id: str) -> SceneDynamicAgent:
        return self._dynamic_agents[agent_id]

    def _bind_env_vars_to_agents(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    async def wait_agents_ready(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def registry_metric_evaluator(self, evaluator: MetricEvaluator):
        self.evaluators.append(evaluator)

    def notify_evaluators_record(self, log: ActionLogBody):
        for evaluator in self.evaluators:
            evaluator.notify_to_record(log)

    def notify_evaluators_compare(self, log: ActionLogBody):
        for evaluator in self.evaluators:
            evaluator.notify_to_compare(log)

    def notify_evaluators_can_stop(self):
        for evaluator in self.evaluators:
            evaluator.notify_can_stop()

    @abstractmethod
    async def _run(self):
        pass  # 所有子类都必须实现这个方法，在其中编排场景运行流程和各角色之间的交互逻辑

    async def run(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def pause(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def resume(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    def interrupt(self):
        ...  # 这里省略具体代码实现，可忽略此方法

    @classmethod
    def get_metadata(cls) -> SceneMetadata:
        ...  # 这里省略具体代码实现，可忽略此方法

    @classmethod
    def from_config(cls, config: config_cls) -> "Scene":
        ...  # 这里省略具体代码实现，可忽略此方法

    @classmethod
    def from_config_file(cls, file_path: str) -> "Scene":
        ...  # 这里省略具体代码实现，可忽略此方法
```

```python
# ActionLogBody 的部分源码，来自 leaf_playground.data.log_body 模块

# 这里省略导入语句

_MetricName = str
_MetricRecord = dict
_MetricRecords = List[_MetricRecord]
_MessageID = str

class LogType(Enum):
    ACTION = "action"
    SYSTEM = "system"


class LogBody(Data):
    id: str = Field(default_factory=lambda: "log_" + uuid4().hex[:8])
    created_at: datetime = Field(default_factory=datetime.utcnow)
    last_update: datetime = Field(default=None)
    log_type: LogType = Field(default=...)
    log_msg: str = Field(default=...)

    def model_post_init(self, __context: Any) -> None:
        if self.last_update is None:
            self.last_update = self.created_at

    @model_validator(mode="before")
    def set_log_type(cls, values):
        ...  # 这里省略具体代码实现，可忽略此方法


class ActionLogBody(LogBody):
    log_type: Literal[LogType.ACTION] = Field(default=LogType.ACTION)
    references: Optional[List[_MessageID]] = Field(default=None)
    response: _MessageID = Field(default=...)
    action_belonged_chain: Optional[str] = Field(default=...)
    ground_truth: Optional[Media] = Field(default=None)
    eval_records: Dict[_MetricName, _MetricRecords] = Field(default=defaultdict(list))
    compare_records: Dict[_MetricName, _MetricRecords] = Field(default=defaultdict(list))
    human_eval_records: Dict[_MetricName, _MetricRecord] = Field(default={})
    human_compare_records: Dict[_MetricName, _MetricRecord] = Field(default={})
```

以下是场景的实现示例，假设在 scene_definition.py 中定义了这是一个老师（静态角色）基于一份多项选择题试卷对学生（非静态角色）进行测试的场景，老师具有准备问题（async def prepare_questions(self, ds_config: DatasetConfig) -> None），发题（async def send_question(self, receivers: List[Profile]) -> Question）和检查考试（async def check_examine_finished(self) -> bool）是否结束的动作，学生具有答题（async def answer_question(self, question: Question, receivers: List[Profile]) -> Answer）的动作。除了 SCENE_DEFINITION，scene_definition.py 中还定义了 Question 和 Answer 两个继承自 leaf_playground.data.message.Message 的数据结构，则 scene.py 模块实现如下：

<code file="scene.py">
import asyncio
from typing import List, Type

from pydantic import Field

from leaf_playground.core.scene import Scene
from leaf_playground.core.scene_definition import SceneConfig
from leaf_playground.data.log_body import ActionLogBody
from leaf_playground.data.media import Text

from .agents.teacher import Teacher
from .agents.student import Student
from .scene_definition import *


ExamineSceneConfig = SceneConfig.create_config_model(SCENE_DEFINITION)


class ExamineSceneLogBody(ActionLogBody):
    ground_truth: Optional[Text] = Field(default=...)


class ExamineScene(Scene, scene_definition=SCENE_DEFINITION, log_body_class=ExamineSceneLogBody):
    config_cls = ExamineSceneConfig
    config: config_cls

    log_body_class: Type[ExamineSceneLogBody]

    def __init__(self, config: config_cls):
        super().__init__(config=config)

        self.teacher: Teacher = self.static_agents["teacher"][0]
        self.students: List[Student] = self.agents["student"]

    async def _run(self) -> None:
        def put_log(log: self.log_body_class):
            self.logger.add_log(log)
            self.notify_evaluators_record(log)

        async def _student_answer(student: Student):
            # using self.message_pool.get_messages can get history messages that visible by the specified agent
            # in this case, we actually only need the newest one
            # in other cases, we may need to use the whole histories
            visible_histories = self.message_pool.get_messages(student.id)
            question = visible_histories[-1]
            answer: Answer = await student.answer_question(question=question, receivers=[self.teacher.profile])
            self.message_pool.put_message(answer)
            log = self.log_body_class(
                references=[question.id],
                responses=answer.id,
                log_msg=f"学生 [{self.id}] 对题目 [{question.question_id}] 进行作答",
                action_belonged_chain=student.role_definition.get_action_definition("answer_question").belonged_chain,
                ground_truth=Text(text=self.teacher.questions[question.question_id]["answer"])
            )
            put_log(log)


        await self.teacher.prepare_questions(self.config.ds_config)
        while not await self.teacher.check_examine_finished():
            question: Question = await self.teacher.send_question(receivers=[s.profile for s in self.students])
            self.message_pool.put_message(question)
            log = self.log_body_class(
                references=None,
                response=question.id,
                log_msg=f"老师发送题目 [{question.question_id}] 给学生们",
                action_belonged_chain=self.teacher.role_definition.get_action_definition("send_question").belonged_chain,
                ground_truth=None
            )
            put_log(log)

            await asyncio.gather(*[_student_answer(stu) for stu in self.students])

        # 场景运行结束，通知评估器
        self.notify_evaluators_can_stop()


__all__ = ["ExamineSceneConfig", "ExamineScene"]
</code>

请遵循上面的需求，并参照我提供给你的实例代码结构，实现 scene.py 模块，请直接给我代码，不要说其他的话。每个模块的代码使用<code file="scene.py">...</code>包裹。
